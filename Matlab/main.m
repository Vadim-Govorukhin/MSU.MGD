%------------------------------------------------
% Файл-функция, реализующая решение ОДУ 
% с помощью генетического алгоритма:
%
% d^2y/dt^2 = x*(1+x^2)/(2*x+3), 0 < x <= pi;
% y'(0) = 0, y(pi) = 0
%-----------------------------------------------------------------
warning('off','all')
syms x
%% Выберем задачу и параметры моделированя:
task = 1; % 0 - Тестовая задача, 1 - Основная задача
% Границы переменной x 
a = 0; b = pi; 

N = 50; % Число "особей" в популяции

% Выберем базисные функциии: 0 - sin(nx); 1 - x^n*(x-pi)^n; 2 - x^n
base = 2; 
M = 10; % Число базисных функций

%% Получаем символьно функционал и общий вид робных функций
[func] = get_problem(task, base, M, x);

%% Main
% В зависимости от случаности в коде необходимо запустить несколько раз
% (каждый раз финальный score будет отличаться)

% "Сходится" == или функция приспособленности стремится к 1, или выходит на
% плато в 0.8-0.95, улучшившись в несколько порядков раз
% task = 0; base = 0; - сходится в пределах 10 итераций
% task = 0; base = 1; - сходится в пределах 100 итераций
% task = 1; base = 0 и base = 1; - сходится очень плохо
% task = 1; base = 2; - сходится пределах 200 итераций
% Но в данном случае необходимо вручную изменять коэффициенты с0 и с1,
% чтобы совпало с граничными условиями

y = get_init_population(func.V, a, b, N, M);

for k=1:200
    % Отбор
    y = selection(y, func.V, a, b, N, M);
    
    % Выведем значение функции приспособленности для лучшей особи
    fprintf('%11.10f\n',y{1,2}); 
    
    % Скрещивание
    y = crossing(y, func.V, a, b, N, M);
    
    % Мутация
    y = mutating(y, func.V, a, b, N, M);
end

%% Вывод результатов на экран
y = selection(y, func.V, a, b, N, M);

fprintf('the best score: %7.6f \nof coeff %s\n',y{1,2}, sprintf('%d ', y{1,1}))
best = num2cell(y{1,1});
digits(5);
disp('Наилучшая пробная функция:')
disp(vpa(expand(func.y(best{1:end},x))))

