%------------------------------------------------
% Файл-функция, реализующая решение ОДУ 
% с помощью генетического алгоритма:
%
% d^2y/dt^2 = x*(1+x^2)/(2*x+3), 0 < x <= pi;
% y'(0) = 0, y(pi) = 0
%-----------------------------------------------------------------
warning('off','all')
syms x
%% Выберем задачу и параметры моделированя:
task = 1; % 0 - Тестовая задача, 1 - Основная задача
% Границы переменной x 
a = 0; b = pi; 

N = 50; % Число "особей" в популяции

% Выберем базисные функциии: 0 - sin(nx); 1 - x^n*(x-pi)^n; 2 - x^n
base = 2; 
M = 10; % Число базисных функций

%% Получаем символьно функционал и общий вид робных функций
[func] = get_problem(task, base, M, x);

%% Main
% В зависимости от случаности в коде необходимо запустить несколько раз
% (каждый раз финальный score будет отличаться)

% "Сходится" == или функция приспособленности стремится к 1, или выходит на
% плато в 0.8-0.95, улучшившись в несколько порядков раз
% task = 0; base = 0; - сходится в пределах 10 итераций
% task = 0; base = 1; - сходится в пределах 100 итераций
% task = 1; base = 0 и base = 1; - сходится очень плохо
% task = 1; base = 2; - сходится пределах 200 итераций
% Но в данном случае необходимо вручную изменять коэффициенты с0 и с1,
% чтобы совпало с граничными условиями

y = get_init_population(func.V, a, b, N, M);
epochs = 200;
F_best = zeros(1, epochs);

for k=1:epochs
    % Отбор
    y = selection(y, func.V, a, b, N, M);
    
    % Выведем значение функции приспособленности для лучшей особи
    F_best(k) = y{1,2};
    % fprintf('%11.10f\n',F_best(k)); 
    
    % Скрещивание
    y = crossing(y, func.V, a, b, N, M);
    
    % Мутация
    y = mutating(y, func.V, a, b, N, M);
end

%% Вывод результатов на экран
y = selection(y, func.V, a, b, N, M);

figure;
plot(F_best)
xlabel('epoch')
ylabel('best of F')
task_name={'test', 'main'};
base_name={'sin(nx)', 'x^n * (x-pi)^n', 'x^n'};
title({['Зависимость функции приспособления от популяции'];
    [' для задачи ', task_name{task+1},' с базисом ', base_name{base+1}]})
grid on; grid minor;


fprintf('the best score: %7.6f \nof coeff %s\n',y{1,2}, sprintf('%d ', y{1,1}))
best = num2cell(y{1,1});

if task == 0 % Вручную отнормируем на константу
   best{1} = 0; 
end
digits(5);
disp('Наилучшая пробная функция:')
disp(vpa(expand(func.y(best{1:end},x))))

if task == 0 % Для основной задачи надо вручную изменять константы
    figure;
    subplot(1,2,1);
    fplot(func.analit_sol,[0,pi])
    hold on;
    fplot(matlabFunction(func.y(best{1:end},x)),[0,pi]);
    title('Сравнение численного и аналитического решений');
    legend('Аналитическое','Численное')
    grid on; grid minor;
    
    subplot(1,2,2);
    fplot(matlabFunction(abs(func.y(best{1:end},x) - func.analit_sol(x))),[0,pi]);
    title('Модуль разности численного и аналитического решений');
    grid on; grid minor;
end